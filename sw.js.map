{"version":3,"sources":["sw.js"],"names":["VERSION","precache","cache","caches","open","addAll","cachedResponse","request","response","match","fetch","updateCache","status","put","Promise","resolve","reject","self","addEventListener","event","waitUntil","method","respondWith"],"mappings":";AAAA,MAAMA,EAAQ,KA6Bd,eAAeC,IAKJC,aAFWC,OAAOC,KAAKJ,IAEjBK,OAAO,IAiBxB,eAAeC,EAAeC,GAEpBL,MAAAA,QAAcC,OAAOC,KAAKJ,GAMzBQ,aAHcN,EAAMO,MAAMF,IAGdG,MAAMH,GAI7B,eAAeI,EAAYJ,GAEjBL,MAAAA,QAAcC,OAAOC,KAAKJ,GAG1BQ,QAAeE,MAAMH,GAKtBC,OAAkB,MAAlBA,EAASI,OAAcV,EAAMW,IAAIN,EAAQC,GAAY,IAAIM,QAAQ,CAACC,EAAQC,IAASD,EAAQ,iBApEpGE,KAAKC,iBAAiB,UAAUC,IAI5BA,EAAMC,UAAUnB,OAKpBgB,KAAKC,iBAAiB,QAAQC,IAEpBZ,MAAAA,EAAQY,EAAMZ,QAGD,OAAhBA,EAAQc,SAIXF,EAAMG,YAAYhB,EAAeC,IAGjCY,EAAMC,UAAUT,EAAYJ","file":"sw.js","sourceRoot":"..","sourcesContent":["const VERSION=\"v1\"\n\n\n//this will bring a call-back \n//'event' will recive it \nself.addEventListener('install',event=>{\n\n    //pre-cache\n    \n    event.waitUntil(precache())\n\n})\n\n//every time a petition happen... it will try to find all elements in the local cache\nself.addEventListener('fetch',event=>{\n\n    const request=event.request\n    //only with \"get\" petitions, other petitions are not needed\n\n    if(request.method!='GET')return\n\n\n    // look for elements in local cache \n    event.respondWith(cachedResponse(request)) \n\n    // but the cache needs to be updated\n    event.waitUntil(updateCache(request))\n})\n\nasync function precache(){\n\n    \n    const cache=await caches.open(VERSION)\n      //adding all elements in the local cache\n    return cache.addAll([\n\n\n        // './',\n        // '/index.html',\n        // './src/index.js',\n        // './src/mediaplayer.js',\n        // './src/plugins/autoPlay.js',\n        // './src/plugins/autoPause.js',\n        // './src/style.css',\n        // './src/videos/ig-11.mp4',\n     \n\n    ])\n}\n\n\nasync function cachedResponse(request){\n\n    const cache = await caches.open(VERSION)\n\n    // the copy of cache is equals to the request? \n    const response=await cache.match(request)\n\n    //if is undefined, we will continue using internet as normal \n    return response || fetch(request)\n}\n\n\nasync function updateCache(request){\n\n    const cache = await caches.open(VERSION)\n\n    //response will have the most updated version of the project\n    const response=await fetch(request)\n\n    //save the value of response in cache\n\n    //the video is partially load, and \"cache.put\" does not support partial requests, so if not is \n  return response.status===200? cache.put(request,response) : new Promise((resolve,reject)=>resolve('Video loaded'))\n  \n}"]}